{% extends "layout.html" %}
{% block content %}
<link href="https://unpkg.com/maplibre-gl@5.6.0/dist/maplibre-gl.css" rel="stylesheet">
<style>
#map {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 100%;
    background: #1a1d28;
}

.spinner-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
}

.spinner-container .lds-spinner {
    position: relative;
    top: 0;
}

#user-sidebar {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 8px;
    padding: 12px;
    z-index: 1000;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    max-height: 50%;
    overflow-y: auto;
    min-width: 150px;
}

#user-sidebar h4 {
    margin: 0 0 10px 0;
    font-size: 14px;
    color: #333;
    border-bottom: 1px solid #ddd;
    padding-bottom: 6px;
}

.user-item {
    display: flex;
    align-items: center;
    padding: 5px 0;
    cursor: pointer;
}

.user-item:hover {
    background: rgba(0,0,0,0.05);
    border-radius: 4px;
}

.user-color-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 8px;
    border: 1px solid rgba(0,0,0,0.2);
}

.user-name {
    font-size: 13px;
    color: #333;
}

#time-slider-container {
    position: absolute;
    width: 90%;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1000;
}

#time-slider {
    width: 100%;
}

#current-time-display {
    margin-top: 10px;
    text-align: center;
    color: #555;
    font-size: 16px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 5px 10px;
    border-radius: 8px;
}

.maplibregl-popup-content {
    font-size: 14px;
    color: #333;
    padding: 10px;
}
</style>

<div class="spinner-container">
    <div class="lds-spinner"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div>
</div>

<div id="map" class="mapIndiv"></div>

<div id="user-sidebar">
    <h4>Users</h4>
    <div id="user-list"></div>
</div>

<div id="time-slider-container">
    <input type="range" id="time-slider" min="0" max="100" value="0" oninput="updateMapByTime(this.value)">
    <div id="current-time-display">Current Time: <span id="time-display">-</span></div>
</div>

<script src="https://unpkg.com/maplibre-gl@5.6.0/dist/maplibre-gl.js"></script>
<script src="{{ url_for('static', filename='js/maplibre-utils.js') }}"></script>

<script>
let map;
let tripsData = [];
let coloursData = {};
let userMarkers = {};
let multiMarkers = [];
let minTimestamp, maxTimestamp;

// Initialize map and load trips
async function initialize() {
    map = await MapLibreUtils.initializeMapLibre({
        container: 'map',
        tileserver: 'osm',
        useGlobe: false,
        center: [0, 30],
        zoom: 2
    });

    if (map.isStyleLoaded()) {
        loadTrips();
    } else {
        map.once('load', loadTrips);
    }
}

function loadTrips() {
    $.get('{{url_for("getMultiTrips", tripIds=tripIds)}}', function(data) {
        tripsData = data[0].reverse();
        coloursData = data[2];
        placePolylines();
        $('.spinner-container').hide();
    });
}

function getPopupContent(username, origin, destination, date, startTime, endTime) {
    return `<strong>${username}</strong><br>${origin} - ${destination}<br>Date: ${date}<br>Time: ${startTime} - ${endTime}`;
}

function getUserColor(username) {
    if (coloursData[username]) {
        const c = coloursData[username];
        return `rgb(${Math.round(c[0] * 255)},${Math.round(c[1] * 255)},${Math.round(c[2] * 255)})`;
    }
    return 'rgb(255,255,255)';
}

function placePolylines() {
    const features = [];
    const timestamps = [];

    tripsData.forEach((tripData, index) => {
        const trip = tripData.trip;
        const path = tripData.path;
        const color = getUserColor(trip.username);

        // Create geodesic path for air trips
        let coords;
        if (trip.type === 'air' && path.length === 2) {
            coords = MapLibreUtils.createGeodesicLine([path[0][1], path[0][0]], [path[1][1], path[1][0]]);
        } else {
            coords = path.map(c => [c[1], c[0]]);
        }

        const startTs = new Date(trip.utc_start_datetime).getTime();
        const endTs = new Date(trip.utc_end_datetime).getTime();

        if (startTs && endTs) {
            timestamps.push(startTs, endTs);
        }

        features.push({
            type: 'Feature',
            geometry: { type: 'LineString', coordinates: coords },
            properties: {
                id: index,
                username: trip.username,
                color: color,
                origin: trip.origin_station,
                destination: trip.destination_station,
                date: trip.start_date,
                startTime: trip.start_time,
                endTime: trip.end_time,
                startTs: startTs,
                endTs: endTs,
                originalCoords: coords,
                type: trip.type
            }
        });

        // Create user marker if not exists
        if (!userMarkers[trip.username]) {
            const el = document.createElement('div');
            el.style.cssText = `background-color: ${color}; width: 14px; height: 14px; border-radius: 50%; border: 2px solid white; cursor: pointer;`;
            
            const marker = new maplibregl.Marker({ element: el, anchor: 'center' })
                .setLngLat(coords[0])
                .setPopup(new maplibregl.Popup({ offset: 10 }).setText(trip.username))
                .addTo(map);
            
            userMarkers[trip.username] = { marker, color, el };
        }
    });

    // Add source
    map.addSource('trips', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: features }
    });

    // Add shadow layer first (underneath)
    map.addLayer({
        id: 'trips-shadow',
        type: 'line',
        source: 'trips',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: {
            'line-color': '#000000',
            'line-width': ['case', ['==', ['get', 'type'], 'air'], 4, 7],
            'line-opacity': 0.8,
            'line-blur': 0
        }
    });

    // Add main layer on top
    map.addLayer({
        id: 'trips-layer',
        type: 'line',
        source: 'trips',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: {
            'line-color': ['get', 'color'],
            'line-width': ['case', ['==', ['get', 'type'], 'air'], 1, 3],
            'line-opacity': 0.8
        }
    });

    // Click handler
    map.on('click', 'trips-layer', (e) => {
        const props = e.features[0].properties;
        new maplibregl.Popup({ offset: 10 })
            .setLngLat(e.lngLat)
            .setHTML(getPopupContent(props.username, props.origin, props.destination, props.date, props.startTime, props.endTime))
            .addTo(map);
    });

    map.on('mouseenter', 'trips-layer', () => map.getCanvas().style.cursor = 'pointer');
    map.on('mouseleave', 'trips-layer', () => map.getCanvas().style.cursor = '');

    // Fit bounds
    const bounds = new maplibregl.LngLatBounds();
    features.forEach(f => f.geometry.coordinates.forEach(c => bounds.extend(c)));
    map.fitBounds(bounds, { padding: 50 });

    // Initialize slider
    if (timestamps.length > 0) {
        minTimestamp = Math.min(...timestamps);
        maxTimestamp = Math.max(...timestamps);
        const slider = document.getElementById('time-slider');
        slider.min = minTimestamp;
        slider.max = maxTimestamp;
        slider.value = minTimestamp;
        slider.step = (maxTimestamp - minTimestamp) / 1000;
    }

    // Store features for animation
    window.tripFeatures = features;
    
    // Build user sidebar
    buildUserSidebar();
}

function buildUserSidebar() {
    const userList = document.getElementById('user-list');
    userList.innerHTML = '';
    
    Object.keys(userMarkers).sort().forEach(username => {
        const color = userMarkers[username].color;
        const item = document.createElement('div');
        item.className = 'user-item';
        item.innerHTML = `<div class="user-color-dot" style="background-color: ${color};"></div><span class="user-name">${username}</span>`;
        item.onclick = () => {
            const lngLat = userMarkers[username].marker.getLngLat();
            map.flyTo({ center: lngLat, zoom: 8 });
            userMarkers[username].marker.togglePopup();
        };
        userList.appendChild(item);
    });
}

function updateMapByTime(value) {
    const currentTime = parseInt(value);
    document.getElementById('current-time-display').innerHTML = 'Current Time: ' + new Date(currentTime).toLocaleString();

    // Remove existing multi-markers
    multiMarkers.forEach(m => m.remove());
    multiMarkers = [];

    // Reset all user markers
    Object.keys(userMarkers).forEach(username => {
        userMarkers[username].el.style.opacity = '1';
        userMarkers[username].marker.getElement().style.pointerEvents = 'auto';
    });

    const updatedFeatures = [];
    const userPositions = {};

    window.tripFeatures.forEach(feature => {
        const props = feature.properties;
        const coords = props.originalCoords;
        const startTs = props.startTs;
        const endTs = props.endTs;
        let visibleCoords = [];

        if (currentTime >= startTs && currentTime <= endTs) {
            const progress = (currentTime - startTs) / (endTs - startTs);
            const pathLength = coords.length;
            const exactIndex = progress * (pathLength - 1);
            const lowerIndex = Math.floor(exactIndex);
            const upperIndex = Math.min(lowerIndex + 1, pathLength - 1);
            const fraction = exactIndex - lowerIndex;
            
            // Interpolate exact marker position
            const p1 = coords[lowerIndex];
            const p2 = coords[upperIndex];
            const markerPos = [
                p1[0] + (p2[0] - p1[0]) * fraction,
                p1[1] + (p2[1] - p1[1]) * fraction
            ];
            
            // Polyline includes all points up to current + the interpolated point
            visibleCoords = coords.slice(0, upperIndex + 1);
            visibleCoords.push(markerPos);
            
            userPositions[props.username] = markerPos;
        } else if (currentTime < startTs) {
            visibleCoords = [];
        } else {
            visibleCoords = coords;
            userPositions[props.username] = coords[coords.length - 1];
        }

        updatedFeatures.push({
            type: 'Feature',
            geometry: { type: 'LineString', coordinates: visibleCoords.length > 1 ? visibleCoords : [[0, 0], [0, 0]] },
            properties: props
        });
    });

    // Update source
    map.getSource('trips').setData({ type: 'FeatureCollection', features: updatedFeatures });

    // Update marker positions
    Object.keys(userPositions).forEach(username => {
        if (userMarkers[username]) {
            userMarkers[username].marker.setLngLat(userPositions[username]);
        }
    });

    // Group nearby markers
    const groups = {};
    const usernames = Object.keys(userPositions);

    usernames.forEach((u1, i) => {
        usernames.slice(i + 1).forEach(u2 => {
            const p1 = userPositions[u1];
            const p2 = userPositions[u2];
            if (p1 && p2) {
                const dist = Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
                if (dist < 0.02) { // ~2km equivalent in degrees
                    let found = false;
                    Object.keys(groups).forEach(g => {
                        if (groups[g].includes(u1) || groups[g].includes(u2)) {
                            groups[g] = [...new Set([...groups[g], u1, u2])];
                            found = true;
                        }
                    });
                    if (!found) groups[`${u1}_${u2}`] = [u1, u2];
                }
            }
        });
    });

    // Create pie markers for groups
    Object.values(groups).forEach(group => {
        if (group.length > 0) {
            group.forEach(u => {
                userMarkers[u].el.style.opacity = '0';
                userMarkers[u].marker.getElement().style.pointerEvents = 'none';
            });

            const colors = group.map(u => userMarkers[u].color);
            const el = document.createElement('div');
            el.innerHTML = createPieSVG(colors);
            el.style.cursor = 'pointer';

            const marker = new maplibregl.Marker({ element: el, anchor: 'center' })
                .setLngLat(userPositions[group[0]])
                .setPopup(new maplibregl.Popup({ offset: 10 }).setText('Users: ' + group.join(', ')))
                .addTo(map);
            
            multiMarkers.push(marker);
        }
    });
}

function createPieSVG(colors) {
    const size = 20;
    let paths = '';
    const angleInc = (2 * Math.PI) / colors.length;

    colors.forEach((color, i) => {
        const start = angleInc * i - Math.PI / 2;
        const end = start + angleInc;
        const x1 = 10 + 10 * Math.cos(start);
        const y1 = 10 + 10 * Math.sin(start);
        const x2 = 10 + 10 * Math.cos(end);
        const y2 = 10 + 10 * Math.sin(end);
        const large = angleInc > Math.PI ? 1 : 0;
        paths += `<path d="M10,10 L${x1},${y1} A10,10 0 ${large},1 ${x2},${y2} Z" fill="${color}"/>`;
    });

    return `<svg width="${size}" height="${size}" viewBox="0 0 20 20">${paths}</svg>`;
}

document.addEventListener('DOMContentLoaded', initialize);
</script>
{% endblock %}